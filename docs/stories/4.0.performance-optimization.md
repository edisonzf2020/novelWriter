# Story 4.0: 优化的性能与响应机制

## Status
Approved

## Story
**As a** 追求效率的作者,
**I want** AI 操作的后台处理机制得到优化，应用的界面绝不卡顿,
**so that** 我可以随时取消不需要的 AI 请求，AI辅助功能不会打断我的创作心流。

## Acceptance Criteria
1. 所有 AI 网络调用和密集计算必须在后台线程中执行
2. 增强日志记录，包含 AI 请求时长、成功率等关键性能指标
3. 引入精细化缓存机制，对重复性查询可返回缓存结果

## Tasks / Subtasks
- [ ] Task 1: 实现AI操作的后台线程处理机制 (AC: 1)
  - [ ] 将所有AI网络调用移至后台线程执行
  - [ ] 实现主线程和AI线程间的安全通信机制
  - [ ] 添加AI操作的取消功能，确保用户可以随时中断
  - [ ] 确保UI界面在AI操作期间保持响应
- [ ] Task 2: 增强AI操作的性能监控和日志记录 (AC: 2)
  - [ ] 实现AI请求时长的精确计时
  - [ ] 记录AI请求的成功率和失败统计
  - [ ] 添加网络延迟和响应时间的监控
  - [ ] 集成性能指标到现有的调试日志系统
- [ ] Task 3: 设计和实现精细化缓存机制 (AC: 3)
  - [ ] 分析AI查询的重复模式，设计缓存策略
  - [ ] 实现基于查询内容和上下文的缓存键生成
  - [ ] 添加缓存失效和清理机制
  - [ ] 实现缓存命中率的监控和优化
- [ ] Task 4: 性能测试和验证
  - [ ] 编写并发AI操作的压力测试
  - [ ] 验证UI响应性在高负载下的表现
  - [ ] 测试缓存机制的有效性和性能提升
  - [ ] 验证取消操作的及时性和资源清理

## Dev Notes

### Previous Story Insights
从 Story 3.3 学到的关键经验：
- Provider抽象层和能力检测机制提供了稳定的基础，现在需要在性能层面进一步优化
- AI配置和调试日志系统已经建立，可以扩展用于性能监控
- 现有的错误处理模式需要适配到异步操作和取消机制中

### 架构约束和设计原则
- **严格遵守分层**: `ai` 包不能有任何 `from novelwriter.gui import ...` 的语句 [Source: docs/architecture/增强功能影响分析.md#新增功能必须遵守的设计标准]
- **使用信号/槽**: `ai_copilot` 与 `gui` 之间的通信必须通过信号/槽，特别是异步操作的状态更新 [Source: docs/architecture/增强功能影响分析.md#新增功能必须遵守的设计标准]
- **可配置与可禁用**: 性能监控和缓存功能必须可以通过 `AIConfig` 配置或禁用 [Source: docs/architecture/增强功能影响分析.md#新增功能必须遵守的设计标准]

### 技术实现细节

#### 后台线程处理架构 [Source: docs/architecture/源码树与模块组织.md]
- 文件位置: `novelwriter/ai/threading.py` (新建)
- 使用PyQt6的 `QThread` 和 `QRunnable` 进行AI操作的异步处理
- 实现线程池管理，避免创建过多线程
- 通过信号/槽机制与UI层安全通信，遵循PyQt6的线程安全原则

#### 性能监控系统 [Source: docs/architecture/源码树与模块组织.md]
- 文件位置: `novelwriter/ai/performance.py` (新建)
- 扩展现有的调试日志系统 `devDebugLog: .ai/debug-log.md`
- 集成到现有的AI Provider架构中，记录每个请求的性能指标
- 提供性能报告和统计分析功能

#### 精细化缓存机制
- 文件位置: `novelwriter/ai/cache.py` (新建)
- 设计基于内容哈希的缓存键策略，考虑上下文和模型参数
- 实现LRU或时间过期的缓存淘汰机制
- 缓存存储考虑内存和磁盘的混合策略，平衡性能和持久性
- 集成到现有的AI配置系统中，支持缓存大小和策略的配置

#### 取消机制和资源管理
- 实现优雅的AI操作取消机制，确保网络请求和计算可以被及时中断
- 添加资源清理逻辑，防止取消操作导致的内存泄漏
- 设计超时机制，避免长时间的AI请求阻塞用户操作

### 文件位置 [Source: docs/architecture/源码树与模块组织.md]
- 线程管理: `novelwriter/ai/threading.py` (新建)
- 性能监控: `novelwriter/ai/performance.py` (新建)
- 缓存机制: `novelwriter/ai/cache.py` (新建)
- API扩展: `novelwriter/ai/api.py` (修改，集成异步支持)
- UI集成: `novelwriter/extensions/ai_copilot/` (修改，添加取消按钮和进度指示)
- 测试文件: `tests/test_ai/test_performance.py` (新建)
- 测试文件: `tests/test_ai/test_threading.py` (新建)
- 测试文件: `tests/test_ai/test_cache.py` (新建)

### Testing [Source: docs/source/technical/tests.rst]
测试策略遵循项目现有的pytest框架：
- 使用 `pytest` 和 `pytest-qt` 进行测试，特别注意异步操作的测试
- GUI测试需要考虑 `QT_QPA_PLATFORM=offscreen` 设置
- 性能测试需要模拟高负载和并发场景
- 缓存测试需要验证不同缓存策略的有效性
- 线程安全测试确保并发操作不会导致数据竞争或死锁

### 技术约束
- Python 3.7+ 兼容性要求，确保异步和线程功能的兼容性 [Source: docs/architecture/高层架构.md#当前技术栈-已验证]
- PyQt6>=6.4.0 依赖要求，利用PyQt6的线程和信号/槽机制 [Source: docs/architecture/高层架构.md#当前技术栈-已验证]
- 必须通过现有的可选依赖系统 `pip install novelWriter[ai]` 进行安装
- 遵循MVC + 分层架构模式，保持AI核心逻辑与UI的分离 [Source: docs/architecture/高层架构.md#当前技术栈-已验证]

### 性能目标
- AI操作启动后，UI应在100ms内返回响应状态
- 缓存命中率应达到30%以上（对于重复查询）
- AI操作的取消响应时间应在500ms内
- 内存使用应保持在合理范围，避免因缓存导致的内存膨胀

## Testing
- `pytest tests/test_ai/test_performance.py tests/test_ai/test_threading.py tests/test_ai/test_cache.py`

## Change Log
| Date | Version | Description | Author |
| --- | --- | --- | --- |

## Dev Agent Record
### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results
*To be filled by QA Agent*